@page "/diagram-editor"
@using BlazorComposite.Models 
@inject IJSRuntime JSRuntime
@implements IDisposable 

<h3>Editor de Diagramas UML (Composite Pattern)</h3>

<div class="toolbar">
    <button class="btn btn-info" @onclick="() => CurrentTool = ToolType.AddRectangle">Añadir Rectángulo</button>
    <button class="btn btn-info" @onclick="() => CurrentTool = ToolType.AddCircle">Añadir Círculo</button>
    
    <button class="btn btn-warning" @onclick="() => CurrentTool = ToolType.AddUmlClass">Añadir Clase UML</button>

    <button class="btn btn-success" @onclick="LoadClassDiagramTemplate">Cargar Plantilla de Clase</button>
</div>

<div class="diagram-canvas-container"
     @onmousedown="OnCanvasMouseDown"
     @onmousemove="OnCanvasMouseMove"
     @onmouseup="OnCanvasMouseUp"
     style="border: 2px solid black; width: 1200px; height: 800px; background-color: #f8f8f8;">

    <svg width="100%" height="100%" @ref="svgElement">
        @foreach (var shape in CanvasShapes)
        {
            @shape.Draw()
        }
    </svg>
</div>

@code {

    // 1. AÑADIR NUEVO TIPO DE HERRAMIENTA
    public enum ToolType { Select, AddRectangle, AddCircle, AddUmlClass }
    public ToolType CurrentTool { get; set; } = ToolType.Select;

    private List<IShape> CanvasShapes = new List<IShape>();
    private ElementReference svgElement;
    private DotNetObjectReference<DiagramEditor>? _dotNetHelper;
    private HashSet<string> _initializedShapeIds = new HashSet<string>();

    // ... (OnInitialized, OnAfterRenderAsync, MoveShape no cambian) ...

    protected override void OnInitialized()
    {
        _dotNetHelper = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        foreach (var shape in CanvasShapes)
        {
            if (!_initializedShapeIds.Contains(shape.Id))
            {
                await JSRuntime.InvokeVoidAsync("diagramInterop.enableDragging", shape.Id, _dotNetHelper);
                _initializedShapeIds.Add(shape.Id);
            }
        }
    }

    [JSInvokable]
    public void MoveShape(string shapeId, double dx, double dy)
    {
        var shapeToMove = CanvasShapes.FirstOrDefault(s => s.Id == shapeId);
        if (shapeToMove != null)
        {
            shapeToMove.Move(dx, dy);
            StateHasChanged();
        }
    }

    // 2. ACTUALIZAR OnCanvasMouseDown
    private async void OnCanvasMouseDown(MouseEventArgs e)
    {
        if (e.Button == 0) // Botón izquierdo
        {
            var bounds = await JSRuntime.InvokeAsync<BoundingClientRect>("diagramInterop.getBoundingClientRect", svgElement);
            if (bounds == null) return; 

            double svgX = e.ClientX - bounds.Left;
            double svgY = e.ClientY - bounds.Top;

            if (CurrentTool == ToolType.AddRectangle)
            {
                CanvasShapes.Add(new Rectangle(svgX, svgY) { Fill = "lightgray" });
                StateHasChanged();
            }
            else if (CurrentTool == ToolType.AddCircle)
            {
                CanvasShapes.Add(new Circle(svgX, svgY) { Fill = "lightblue" });
                StateHasChanged();
            }
            // ¡NUEVA LÓGICA!
            else if (CurrentTool == ToolType.AddUmlClass)
            {
                var newClass = new UmlClass(svgX, svgY)
                {
                    ClassName = "NewClass",
                    Attributes = new List<string> { "- attribute: string" },
                    Methods = new List<string> { "+ Method(param: int): bool" }
                };
                CanvasShapes.Add(newClass);
                StateHasChanged(); // Vuelve a dibujar la UI
            }
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs e)
    {
    }

    private void OnCanvasMouseMove(MouseEventArgs e)
    {
    
    }

    // 3. ¡ACTUALIZAR LA PLANTILLA! (Esta es la parte clave)
    private void LoadClassDiagramTemplate()
    {
        CanvasShapes.Clear(); 
        _initializedShapeIds.Clear(); 

        // --- ¡AHORA USAMOS UmlClass EN LUGAR DE Rectangle! ---
        
        var userClass = new UmlClass(50, 50)
        {
            ClassName = "User",
            Attributes = new List<string> { "- userId: int", "- username: string" },
            Methods = new List<string> { "+ Login()", "+ Logout()" }
        };

        var orderClass = new UmlClass(300, 50)
        {
            ClassName = "Order",
            Attributes = new List<string> { "- orderId: int", "- orderDate: DateTime" },
            Methods = new List<string> { "+ AddItem(item: Product)", "+ CalculateTotal(): double" }
        };
        
        var productClass = new UmlClass(550, 50)
        {
            ClassName = "Product",
            Attributes = new List<string> { "- productId: int", "- price: double", "- stock: int" },
            Methods = new List<string> { "+ UpdateStock(qty: int)" }
        };

        CanvasShapes.Add(userClass);
        CanvasShapes.Add(orderClass);
        CanvasShapes.Add(productClass);
        
        // (En un futuro, las líneas de relación también serían "IShape")

        StateHasChanged();
    }

    public void Dispose()
    {
        _dotNetHelper?.Dispose();
    }
}